{
  "hash": "7efeab18396c53d8030cefab13e6bff0",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Nested Stochastic Blockmodels Part 2\nauthor: John McLevey\ndate: 2026-02-05\nexcerpt: Fitting and visualizing nested stochastic blockmodels with graph-tool.\nexecute:\n  echo: true\n  warning: false\n  message: false\nformat:\n  gfm: default\n---\n\n\nIn this second post, we continue our exploration of nested stochastic blockmodels by fitting a model to the political blogs network.\n\n## Loading the Network\n\nLet's start by loading our network data and examining its structure.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\n\n# Create a simple example adjacency matrix\nnp.random.seed(42)\nn_nodes = 10\nadjacency = np.random.randint(0, 2, size=(n_nodes, n_nodes))\nadjacency = (adjacency + adjacency.T) // 2  # Make symmetric\nnp.fill_diagonal(adjacency, 0)\n\ndf = pd.DataFrame(adjacency,\n                  columns=[f\"node_{i}\" for i in range(n_nodes)],\n                  index=[f\"node_{i}\" for i in range(n_nodes)])\n\nprint(\"Example adjacency matrix:\")\nprint(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nExample adjacency matrix:\n        node_0  node_1  node_2  node_3  node_4  node_5  node_6  node_7  \\\nnode_0       0       0       0       0       0       0       0       0   \nnode_1       0       0       0       0       0       0       0       1   \nnode_2       0       0       0       1       1       0       0       0   \nnode_3       0       0       1       0       1       0       0       0   \nnode_4       0       0       1       1       0       0       0       0   \nnode_5       0       0       0       0       0       0       1       0   \nnode_6       0       0       0       0       0       1       0       0   \nnode_7       0       1       0       0       0       0       0       0   \nnode_8       0       1       0       0       0       0       1       0   \nnode_9       1       0       1       0       1       0       1       1   \n\n        node_8  node_9  \nnode_0       0       1  \nnode_1       1       0  \nnode_2       0       1  \nnode_3       0       0  \nnode_4       0       1  \nnode_5       0       0  \nnode_6       1       1  \nnode_7       0       1  \nnode_8       0       1  \nnode_9       1       0  \n```\n:::\n:::\n\n\n## Summary Statistics\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\ntotal_edges = adjacency.sum() // 2\ndensity = total_edges / (n_nodes * (n_nodes - 1) / 2)\nprint(f\"Number of nodes: {n_nodes}\")\nprint(f\"Number of edges: {total_edges}\")\nprint(f\"Network density: {density:.3f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNumber of nodes: 10\nNumber of edges: 13\nNetwork density: 0.289\n```\n:::\n:::\n\n\n## Next Steps\n\nIn the next post, we'll fit the actual nested SBM and visualize the results.\n\n",
    "supporting": [
      "2026-02-05-nsbm-2_files"
    ],
    "filters": []
  }
}