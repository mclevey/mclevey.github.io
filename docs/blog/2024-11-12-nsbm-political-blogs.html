<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Modeling and Visualizing Network Structure with graph-tool – John McLevey</title>
  <link rel="stylesheet" href="../styles.css">
  <!-- Highlight.js themes -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-light.min.css" id="hljs-light">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/nord.min.css" id="hljs-dark" disabled>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/python.min.js"></script>
</head>
<body>
  <header>
    <nav>
      <a href="../index.html" class="nav-home">JM.</a>
      <a href="../cv.html">CV</a>
      <a href="../research.html">Research</a>
      <a href="../teaching.html">Teaching & Supervision</a>
      <a href="../software-data.html">Software & Data</a>
      <a href="../blog.html" class="active">Blog</a>
      <button class="theme-toggle" onclick="toggleTheme()" aria-label="Toggle theme">
        <span class="icon-moon">☽</span>
        <span class="icon-sun">☼</span>
      </button>
    </nav>
  </header>
  <main>
    <div class="post-header">
      <div class="post-date">2024-11-12</div>
      <h1>Modeling and Visualizing Network Structure with graph-tool</h1>
    </div>
    <div class="post-content">
<p>I iteratively develop network visualizations of Adamic and Glance's political blogs network and show how to fit a simple nested stochastic blockmodel to the observed network.</p>
<p><strong>Categories:</strong> Python, graph-tool, Networks, Nested Stochastic Blockmodels, Bayesian Data Analysis, Generative Modeling, Visualization</p>
<h2>Setup</h2>
<pre><code class="language-python">import numpy as np
import graph_tool.all as gt
import matplotlib as mpl
from icsspy.networks import rotate_positions

print(f&quot;Using graph-tool version {gt.__version__}&quot;)
</code></pre>
<p>Load the data.</p>
<pre><code class="language-python">g = gt.collection.data[&quot;polblogs&quot;]
print(g)
</code></pre>
<h2>Property Maps</h2>
<p>We can look up the political class for any given node by passing its integer ID. For example, vertex 30:</p>
<pre><code class="language-python">g.vp.value[30]
</code></pre>
<p>To view all classifications, we can iterate over the vertices and print each vertex ID followed by its class label.</p>
<pre><code class="language-python">for v in g.vertices():
    print(v, g.vp.value[v])
</code></pre>
<pre><code class="language-python">political_colors = {0: &quot;#2F357E&quot;, 1: &quot;#D72F32&quot;}  # color map
vertex_political_colors = g.new_vertex_property(&quot;string&quot;)  # new vertex property

# assign colors to each vertex based on the political classification
for v in g.vertices():
    vertex_political_colors[v] = political_colors[g.vp.value[v]]
</code></pre>
<p>As a first step, let's recreate the political blogs figures we've seen so far (including those based on the nested SBM). We'll assign node positions using the <strong>stable force directed placement</strong> function, <code>sfdp_layout()</code>. This will more-or-less recreate the force directed layout from the original.</p>
<pre><code class="language-python">pos = gt.sfdp_layout(g)

f1 = gt.graph_draw(
    g, pos,
    vertex_fill_color=vertex_political_colors,
    output_size=(1200, 1200),
    inline=True
)
</code></pre>
<p>Let's just focus on the giant component for a cleaner visualization. We'll also rotate the graph's position to match the figures more closely.</p>
<pre><code class="language-python">giant = gt.extract_largest_component(g, directed=True)

pos = gt.sfdp_layout(giant)
pos = rotate_positions(pos, a=90)

f2 = gt.graph_draw(
    giant, pos,
    vertex_fill_color=vertex_political_colors,
    output_size=(1200, 1200),
    inline=True
)
</code></pre>
<h2>Fitting a First NSBM</h2>
<p>Next, we fit an SBM and color the nodes based on their estimated block membership.</p>
<pre><code class="language-python">blockstate = gt.minimize_nested_blockmodel_dl(giant)
blockstate_level_0 = blockstate.levels[0]
blockstate_level_0
</code></pre>
<p>We can use the <code>.draw()</code> method for blockstate objects to visualize the network with inferred communities.</p>
<pre><code class="language-python">f3 = blockstate_level_0.draw(
    pos=pos,
    output_size=(1200, 1200),
)
</code></pre>
<p>As a refinement step <strong>based on model criticism</strong>, we'll adjust the force-directed layout by adding an attractive force between nodes in the same block. This is done by passing the following arguments to <code>sfdp_layout()</code>:</p>
<ul>
<li><code>groups</code>: A vertex property map that assigns nodes to specific groups, in this case, block assignments at the lowest level of the nested SBM (<code>blockstate_level_0.b</code>). This adds additional attractive forces for block membership in the layout.</li>
<li><code>gamma</code>: Controls the strength of the attractive force for nodes in the same block. A small value corresponds to a weak force and more spread out clusters, while a larger value results in more compact clusters.</li>
</ul>
<pre><code class="language-python">pos_refined = gt.sfdp_layout(g, groups=blockstate_level_0.b, gamma=.04)
pos_refined = rotate_positions(pos_refined, 125)  # make it horizontal
</code></pre>
<h2>Divided They Blog?</h2>
<h3>Adjusting Node Colors &amp; Exploring Hierarchy</h3>
<p>For the final adjustment, let's assign node colors based on political classification rather than block membership and use a layout that is designed to emphasize the hierarchical structure of the network.</p>
<pre><code class="language-python">f5 = blockstate.draw(
    vertex_fill_color=vertex_political_colors,
    output_size=(1200, 1200),
    inline=True,
)
</code></pre>
<p>This visualization reveals the hierarchical structure more clearly. The blue square node right in the middle of the network represents the entire graph merged into one group at the highest level of the block hierarchy. As you move outward from the center, the graph splits into smaller and smaller blocks, which correspond to different political blogs at the lowest level of the block hierarchy.</p>
<p>You may notice that the nested SBM reveals a more complex structure than a simple left-right division. The hierarchy shows internal differentiation within each political cluster, revealing sub-communities that were not as apparent in the force-directed layout.</p>
<h3>Summary</h3>
<p>With that, we've successfully recreated the series of political blog network figures using <code>graph-tool</code>. We learned how to:</p>
<ul>
<li>Extract the giant component from a network</li>
<li>Fit our first nested Stochastic Blockmodel (NSBM)</li>
<li>Create a series of visualizations of the network and its hierarchical block structure</li>
<li>Adjust force-directed layouts to add additional attractors for group memberships based on simple model criticism</li>
<li>Modify and refine the visual properties of networks at different levels of the block hierarchy</li>
</ul>
<p>In the next part of the tutorial, we'll explore the Enron email networks, applying similar techniques and deepening our understanding of community detection in large networks.</p>
    </div>
    <a href="../blog.html" class="back-link">← Back to blog</a>
  </main>

  <footer id="site-footer"></footer>
  <script>
    fetch('../footer.html')
      .then(response => response.text())
      .then(html => {
        document.getElementById('site-footer').innerHTML = html;
      });
  </script>

  <!-- Lightbox -->
  <div class="lightbox-overlay" id="lightbox">
    <span class="lightbox-close">&times;</span>
    <img src="" alt="" id="lightbox-img">
  </div>

  <script>
    // Initialize highlight.js
    hljs.highlightAll();

    // Theme toggle with highlight.js theme switching
    function updateHljsTheme(theme) {
      const lightTheme = document.getElementById('hljs-light');
      const darkTheme = document.getElementById('hljs-dark');
      if (theme === 'dark') {
        lightTheme.disabled = true;
        darkTheme.disabled = false;
      } else {
        lightTheme.disabled = false;
        darkTheme.disabled = true;
      }
    }

    function toggleTheme() {
      const html = document.documentElement;
      const next = html.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
      html.setAttribute('data-theme', next);
      localStorage.setItem('theme', next);
      updateHljsTheme(next);
    }

    const saved = localStorage.getItem('theme') || (matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
    if (saved === 'dark') document.documentElement.setAttribute('data-theme', 'dark');
    updateHljsTheme(saved);

    // Lightbox
    const lightbox = document.getElementById('lightbox');
    const lightboxImg = document.getElementById('lightbox-img');

    document.querySelectorAll('.post-content img').forEach(img => {
      img.addEventListener('click', () => {
        lightboxImg.src = img.src;
        lightboxImg.alt = img.alt;
        lightbox.classList.add('active');
      });
    });

    lightbox.addEventListener('click', () => {
      lightbox.classList.remove('active');
    });

    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') lightbox.classList.remove('active');
    });
  </script>
</body>
</html>
